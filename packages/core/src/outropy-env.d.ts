/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/api/tasks/create": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create new Task
         * @description Create a new Task using the following information:
         *
         *
         *     <Note>
         *         Creation will fail if an existing task with the same name and type already exists.
         *     </Note>
         *     <Note>
         *         Not all tasks types support all the fields, see each task documentation for more details.
         *     </Note>
         */
        post: operations["create_task_api_tasks_create_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/tasks/execute": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Execute Task
         * @description Execute a task with the given input.
         *     Tasks are executed asynchronously, this will return a URN for the task run which can be used to retrieve the results later.
         */
        post: operations["execute_task_api_tasks_execute_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/tasks/runs/{task_run_urn}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Task Run
         * @description Retrieve informationa about a Task Run.
         *
         *     This will return its status and execution related information.
         *
         *     The URN can be found in the 'urn' field of the response from the [Execute Task](/api-reference/endpoint/execute-task) endpoint.
         */
        get: operations["get_task_run_api_tasks_runs__task_run_urn__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/tasks/runs/{task_run_urn}/inputs": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Run Inputs
         * @description Retrieve the inputs used for a given task run.
         *
         *     Those inputs can be used to re-execute the run with the same task or a similar one.
         *     See the [Execute Task](/api-reference/endpoint/execute-task) endpoint for more details.
         */
        get: operations["get_task_run_inputs_api_tasks_runs__task_run_urn__inputs_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/tasks/by-name/{name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get Task by Name */
        get: operations["get_task_by_name_api_tasks_by_name__name__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/data/upload": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Upload Data
         * @description Upload data to Outropy.
         *
         *     The uploaded content currently must be text-based.
         *
         *     This returns the URN of the uploaded file.
         *
         *     The returned URN can be used as subject when executing tasks.
         *
         *     <Note>
         *         You must specify the file's mime type in the `X-Outropy-Upload-Mime-Type` header.
         *     </Note>
         */
        post: operations["upload_data_api_data_upload_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/data/{data_urn}/metadata": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Data Metadata
         * @description Retrieve metadata for a file by URN.
         *
         *     The metadata includes the file name, mime type, size in bytes, and any additional metadata.
         *
         *
         *     <Note>
         *         See the [File Metadata](/file-metadata) for explanation of how additinal metadata is used by the Outropy platform.
         *     </Note>
         */
        get: operations["get_metadata_api_data__data_urn__metadata_get"];
        put?: never;
        /**
         * Set Data Metadata
         * @description Set the metadata of a data item.
         *
         *     See [File Metadata](/file-metadata) for known keys by the Outropy platform.
         */
        post: operations["set_metadata_api_data__data_urn__metadata_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/data/{data_urn}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Download Data
         * @description Fetch data by URN.
         *
         *     The downloaded data is returned as plain text.
         *
         *     <Note>
         *         See the [Upload Data](/api-reference/endpoint/upload-data) endpoint for more details on how to upload data.
         *     </Note>
         *
         *     <Note>
         *         In order to fetch the file name and mime type, use the [Get File Metadata](/api-reference/endpoint/get-file-metadata) endpoint.
         *     </Note>
         */
        get: operations["get_data_api_data__data_urn__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/data-sources/create": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create Data Source
         * @description Create a new data source.
         *
         *     This create a new data source and a task that can be used to ingest data into it.
         *
         *     In order for this data source to be useful, you will need to create at least one index on it.
         */
        post: operations["create_data_source_api_data_sources_create_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/data-sources/by-name/{name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Data Source by Name
         * @description Get a data source by its name.
         */
        get: operations["get_data_source_by_name_api_data_sources_by_name__name__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/data-sources/create-index": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create Index
         * @description Create an index on a given data source.
         *
         *     You can customize the index by means of its indexing task.
         */
        post: operations["create_index_api_data_sources_create_index_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/data-sources/index-by-name": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Index by Name
         * @description Get an index by its name.
         */
        get: operations["get_index_by_name_api_data_sources_index_by_name_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/data-sources/{urn_str}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Data Source by URN
         * @description Get a data source by its URN.
         *
         *     Returns information about a data source.
         */
        get: operations["get_data_source_api_data_sources__urn_str__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        /** Body_upload_data_api_data_upload_post */
        Body_upload_data_api_data_upload_post: {
            /**
             * File
             * Format: binary
             * @description Data to upload
             */
            file: string;
        };
        /** CreateDataSourceRequest */
        CreateDataSourceRequest: {
            /**
             * Name
             * @description The unique name of this data source
             */
            name: string;
            /**
             * Description
             * @description Description of the content to be store in this data source
             */
            description?: string | null;
            /** @description Directives to control how the ingestion task will behave */
            directives?: components["schemas"]["Directives"] | null;
        };
        /** CreateIndexRequest */
        CreateIndexRequest: {
            /**
             * Name
             * @description The unique name of this index among the associated data source
             */
            name: string;
            /**
             * Data Source Urn
             * @description The URN of the data source to index
             */
            data_source_urn: string;
            /**
             * Description
             * @description Description of the content to be indexed
             */
            description?: string | null;
            /** @description The type of index to create */
            type: components["schemas"]["IndexerType"];
        };
        /** CreateTaskRequest */
        CreateTaskRequest: {
            /** @description The task you want to perform */
            task_type: components["schemas"]["TaskNames"];
            /**
             * Name
             * @description The unique name of the task
             */
            name: string;
            /**
             * Input Type
             * @description A json schema describing the input type for requests to the task
             */
            input_type?: Record<string, never> | null;
            /**
             * Output Type
             * @description The output type for requests to the task
             */
            output_type?: Record<string, never> | null;
            /**
             * Examples
             * @description Examples of expected input and output for the task
             * @default []
             */
            examples: [
                unknown,
                unknown
            ][];
            /**
             * Reference Data
             * @description The data sources that should be used as reference data for the task
             * @default []
             */
            reference_data: string[];
            /**
             * Prompt
             * @description The prompt for the task
             */
            prompt?: string | null;
            /** @description The default directives to be applied when running the task */
            directives?: components["schemas"]["Directives"] | null;
            /**
             * Collection Name
             * @description The name of the collection to use if this task end up creating one
             */
            collection_name?: string | null;
        };
        /** DataResponse */
        DataResponse: {
            /**
             * Urns
             * @description The URN of data being processed
             */
            urns: components["schemas"]["RawUrn"][];
        };
        /** DataSourceMetadata */
        DataSourceMetadata: {
            /** Urn */
            urn: string;
            /** File Name */
            file_name: string;
            /** Mime Type */
            mime_type: string;
            /** Size Bytes */
            size_bytes: number;
            /** Metadata */
            metadata: {
                [key: string]: string;
            };
        };
        /** DataSourceResponse */
        DataSourceResponse: {
            /** Urn */
            urn: string;
            /** Ingestion Task Urn */
            ingestion_task_urn: string | null;
            /** Name */
            name: string;
            /** Description */
            description: string;
            /** Type Str */
            type_str: string;
            /** Status Str */
            status_str: string;
            /** Icon */
            icon: string;
            /** Href */
            href: string;
        };
        /** Directives */
        Directives: {
            /**
             * Session Id
             * @description The current session ID if this belongs to a session
             */
            session_id?: string | null;
            /**
             * Latency
             * @description How the server should prioritize low latency, from 0 to 100. If not specified, the server will infer the best value.
             * @default -999999999
             */
            latency: number;
            /**
             * Accuracy
             * @description How the server should prioritize high accuracy of the results, from 0 to 100. If not specified, the server will infer the best value.
             * @default -999999999
             */
            accuracy: number;
            /**
             * Cost
             * @description How the server should prioritize minimizing costs, from 0 to 100. If not specified, the server will infer the best value.
             * @default -999999999
             */
            cost: number;
            /**
             * Reproducibility
             * @description How the server should prioritize returning the same result as previous queries of similar nature, from 0 to 100. If not specified, the server will infer the best value.
             * @default -999999999
             */
            reproducibility: number;
            /**
             * Freshness
             * @description How the server should prioritize freshness, from 0 to 100. If not specified, the server will infer the best value.
             * @default -999999999
             */
            freshness: number;
            /**
             * Personalization
             * @description How the server should prioritize personalization, from 0 to 100. If not specified, the server will infer the best value.
             * @default -999999999
             */
            personalization: number;
            /**
             * Recall
             * @description How the server should prioritize recall in future queries for the same session, from 0 to 100. If not specified, the server will infer the best value.
             * @default -999999999
             */
            recall: number;
            /**
             * Creativity
             * @description How the server should prioritize creativity in the results, from 0 to 100. If not specified, the server will infer the best value.
             * @default -999999999
             */
            creativity: number;
        };
        /** ExecuteTaskRequest */
        ExecuteTaskRequest: {
            /**
             * Task Urn
             * @description The URN of the task to run
             */
            task_urn: string;
            /**
             * Subject Urns
             * @description The URN of the subjects for the request, at least one is required
             */
            subject_urns: string[];
            /** @description (Optional) The directives to apply to this request, overriding the task defaults */
            directives?: components["schemas"]["Directives"] | null;
            /**
             * Reference Data
             * @description (Optional) Additional reference data sources to use for this request
             */
            reference_data?: string[] | null;
        };
        /** HTTPValidationError */
        HTTPValidationError: {
            /** Detail */
            detail?: components["schemas"]["ValidationError"][];
        };
        /** IndexResponse */
        IndexResponse: {
            /** Urn */
            urn: string;
            /** Data Source Urn */
            data_source_urn: string;
            /** Ingestion Task Urn */
            ingestion_task_urn: string;
            /** Href */
            href: string;
        };
        /**
         * IndexerType
         * @constant
         * @enum {string}
         */
        IndexerType: "semantic_text";
        /** PipelineCreateResponse */
        PipelineCreateResponse: {
            /** Urn */
            urn: string;
            /** Href */
            href: string;
        };
        /** RawUrn */
        RawUrn: string;
        /** TaskExecuteResponse */
        TaskExecuteResponse: {
            /**
             * Urn
             * @description The unique URN of the task run, can be used to retrieve its status and results later.
             */
            urn: string;
            /**
             * Href
             * @description URL that can be used to visualize the task run
             */
            href: string;
        };
        /**
         * TaskNames
         * @enum {string}
         */
        TaskNames: "transform_with_ref_data" | "extract" | "transform" | "recommend" | "ingest_reference_data" | "ingest_document" | "text_to_text" | "index_document";
        /** TaskRunResponse */
        TaskRunResponse: {
            /**
             * Urn
             * @description The URN for this task run
             */
            urn: string;
            /**
             * Pipeline Urn
             * @description The URN of the pipeline that executed this task
             */
            pipeline_urn: string;
            /**
             * Pipeline Version Urn
             * @description The URN of the pipeline version that executed this task
             */
            pipeline_version_urn: string;
            /**
             * Href
             * @description URL that can be used to visualize the task run
             */
            href: string;
            /**
             * Results Urn
             * @description The URN of the results of this task run
             */
            results_urn?: string | null;
            /**
             * Created At
             * Format: date-time
             * @description When this task run was created
             */
            created_at: string;
            /**
             * Updated At
             * Format: date-time
             * @description When this task run was last updated
             */
            updated_at: string;
            /**
             * Duration
             * @description The duration of this task run in seconds
             */
            duration: number;
            /**
             * Pipeline Name
             * @deprecated
             * @description Internal usage, will be removed in the future
             */
            pipeline_name: string;
            /**
             * Task Type
             * @deprecated
             * @description Internal usage, will be removed in the future
             */
            task_type: string;
            /**
             * Task Icon
             * @deprecated
             * @description Internal usage, will be removed in the future
             */
            task_icon: string;
            /**
             * Pipeline Version Name
             * @deprecated
             * @description Internal usage, will be removed in the future
             */
            pipeline_version_name: string;
            /**
             * Status Str
             * @deprecated
             * @description Internal usage, will be removed in the future
             */
            status_str: string;
            /**
             * Status Description
             * @description A description of the task run status
             */
            status_description: string;
        };
        /** ValidationError */
        ValidationError: {
            /** Location */
            loc: (string | number)[];
            /** Message */
            msg: string;
            /** Error Type */
            type: string;
        };
    };
    responses: never;
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    create_task_api_tasks_create_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateTaskRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PipelineCreateResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    execute_task_api_tasks_execute_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ExecuteTaskRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TaskExecuteResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_task_run_api_tasks_runs__task_run_urn__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The URN of the task run to retrieve */
                task_run_urn: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TaskRunResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_task_run_inputs_api_tasks_runs__task_run_urn__inputs_get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The URN of the task run to retrieve the inputs for */
                task_run_urn: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ExecuteTaskRequest"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_task_by_name_api_tasks_by_name__name__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": string;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    upload_data_api_data_upload_post: {
        parameters: {
            query?: never;
            header: {
                /** @description The mime type of the data to upload */
                "x-outropy-upload-mime-type": string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "multipart/form-data": components["schemas"]["Body_upload_data_api_data_upload_post"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DataResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_metadata_api_data__data_urn__metadata_get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                data_urn: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DataSourceMetadata"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    set_metadata_api_data__data_urn__metadata_post: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                data_urn: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    [key: string]: string;
                };
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": string;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_data_api_data__data_urn__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                data_urn: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "text/plain": string;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    create_data_source_api_data_sources_create_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateDataSourceRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DataSourceResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_data_source_by_name_api_data_sources_by_name__name__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DataSourceResponse"] | null;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    create_index_api_data_sources_create_index_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateIndexRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["IndexResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_index_by_name_api_data_sources_index_by_name_get: {
        parameters: {
            query: {
                data_source_name: string;
                index_name: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["IndexResponse"] | null;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_data_source_api_data_sources__urn_str__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                urn_str: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DataSourceResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
}
